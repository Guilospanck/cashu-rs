use std::collections::BTreeMap;

use bitcoin::secp256k1::PublicKey;
use serde::{Deserialize, Serialize};

pub type Amount = u64;

/// A [`Proof`] is also called an `input` and is generated by Alice (wallet) from a [`BlindSignature`] it received.
/// An array [`Proof``] is called Proofs
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Proof {
  /// amount of the [`Proof`]
  pub amount: Amount,
  /// keyset id of the mint public keys that signed the token (hex string)
  pub id: String,
  /// utf-8 encoded string (it is the `x`)
  pub secret: String,
  /// unblinded signature on `secret`
  #[serde(rename = "C")]
  pub c: PublicKey,
}

pub type Proofs = Vec<Proof>;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Token {
  /// the mint URL
  pub mint: String,
  /// proofs of the token
  pub proofs: Proofs,
}

/// An encrypted ("blinded") secret and an amount is sent from Alice (wallet) to Bob (mint) for minting tokens or for swapping tokens.
/// A [`BlindedMessage`] is also called an `output`.
#[derive(Debug, Serialize, Deserialize)]
pub struct BlindedMessage {
  /// the value for the requested [`BlindSignature`]
  pub amount: Amount,
  /// requested keyset ID (hex) from which we expect a signature
  pub id: String,
  /// blinded secret message generated by Alice (wallet)
  #[serde(rename = "B_")]
  pub b: PublicKey,
}

pub type BlindedMessages = Vec<BlindedMessage>;

/// A [`BlindSignature`] is sent from Bob (mint) to Alice (wallet) after minting tokens or after swapping tokens.
/// A [`BlindSignature`] is also called a `promise`.
#[derive(Debug, Serialize, Deserialize)]
pub struct BlindSignature {
  /// value of the blinded token
  pub amount: Amount,
  /// keyset id (hex) of the mint keys that signed the token
  pub id: String,
  /// blinded signature on the secret message `B_` sent by [`BlindedMessage`]
  #[serde(rename = "C_")]
  pub c: PublicKey,
}

pub type Keys = BTreeMap<Amount, PublicKey>;

#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, PartialEq, strum::Display)]
pub enum Unit {
  BTC,
  SAT,
}

/*
/// A set of all Ks for a set of amounts is called a keyset.
///
/// Each keyset is identified by its keyset id. The keyset ID
/// is a lowercase hex string.
/// It can be computed by anyone from its public keys:
///
/// 1-Sort public keys by their amount in ascending order
/// 2-concatenate all public keys to one byte array
/// 3- hash256 the concatenated public keys
/// 4-take the first 14 chars of hte hex-encoded hash
/// 5-prefix it with a keyset ID version byte
///
/// Example in python:
/// ```py
/// def derive_keyset_id(keys: Dict[int, PublicKey]) -> str:
///   sorted_keys = dict(sorted(keys.items()))
///   pubkeys_concat = b"".join([p.serialize() for p in sorted_keys.values()])
///   return "00" + hashlib.sha256(pubkeys_concat).hexdigest()[:14]
/// ```
///
/// A mint responds only with its active keysets
/// Active keysets are the ones that the mint can sign promises
/// with it
///
/// The mint will accept tokens from inactive keysets as inputs
/// (proofs) but will not sign with them for new outputs
/// (blinded messages)
///
/// The active keysets can change over time, for example due to a
/// key rotation.
/// A List of all keysets (active and inactive) can be requested
/// separately (see nut02)
///
/// A mint can support multiple keysets at the same time,
/// but will only respond with active keysets on the
/// endpoints GET /v1/keys
///
/// A wallet can ask for the keys of a specific keyset
/// (active or inactive) requesting via
/// the endpoint GET /v1/keys/{keyset_id} (nut02).
///
/// Keyset generation
///
/// The mint is free to use whichever key generation method
/// they like.
/// Mints MUST generate a keyset for each unit they support
///
///
///
/// */
