use bitcoin::secp256k1::{Parity, PublicKey, XOnlyPublicKey};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

/// An encrypted ("blinded") secret and an amount is sent from Alice (user) to Bob (mint) for minting tokens or for swapping tokens.
/// A [`BlindedMessage`] is also called an output.
#[derive(Debug, Serialize, Deserialize)]
struct BlindedMessage {
  /// the value for the requested [`BlindSignature`]
  amount: u64,
  /// requested keyset ID from which we expect a signature
  id: String,
  /// blinded secret message generated by Alice (user)
  #[serde(rename = "B_")]
  b: String,
}

/// A [`BlindSignature`] is sent from Bob (mint) to Alice (user) after minting tokens or after swapping tokens.
/// A [`BlindSignature`] is also called a promise.
#[derive(Debug, Serialize, Deserialize)]
struct BlindSignature {
  /// value of the blinded token
  amount: u64,
  /// keyset id of the mint keys that signed the token
  id: String,
  /// blinded signature on the secret message `B_` sent by [`BlindedMessage`]
  #[serde(rename = "C_")]
  c: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Mint {
  #[serde(rename = "K")]
  pub k: PublicKey,
}

impl Mint {
  fn new() -> Self {
    let mint_secret = b"larry";
    let pubkey = hash_to_curve(mint_secret.to_vec());

    Self { k: pubkey }
  }

  fn mint_or_swap_tokens(self, message: BlindedMessage) -> BlindSignature {
    println!("{:?}", message);

    // TODO
    let generated_new_private_key = "todo";

    // TODO
    // Bob sends back to Alice blinded key: C_ = kB_ (these two steps are the DH key exchange) (signing)

    BlindSignature {
      amount: message.amount,
      id: message.id,
      c: "".to_string(),
    }
  }
}

#[derive(Debug, Serialize, Deserialize)]
struct Wallet {}

impl Wallet {
  // Protocol
  fn begin() {
    // Mint Bob publishes public key K = kG
    let mint = Mint::new();

    // Alice picks secret x and computes Y = hash_to_curve(x)
    let wallet_secret = b"potato"; // x
    let y = hash_to_curve(wallet_secret.to_vec());

    // Alice sends to Bob: B_ = Y + rG with r being a random blinding factor (blinding)
    let alice_random_blinding_factor = b"alice-random-blinding-factor";
    let rg = get_point_on_curve(alice_random_blinding_factor.to_vec());
    let y_bytes = y.serialize();
    let rg_bytes = rg.serialize();
    let b_ = [y_bytes, rg_bytes].concat();
    let b_ = hex::encode(b_);
    let blinded_message = BlindedMessage {
      amount: 10,
      b: b_,
      id: "first#test".to_string(),
    };
  }
}

const DOMAIN_SEPARATOR: &[u8] = "Secp256k1_HashToCurve_Cashu_".as_bytes();

fn sha256_hasher(data: Vec<u8>) -> Vec<u8> {
  let mut hasher = Sha256::new();
  hasher.update(data);
  hasher.finalize()[..].to_vec()
}

fn _get_hashed_value(msg: Vec<u8>, counter: u32) -> Vec<u8> {
  let mut msg_to_hash = 0x02_u8.to_be_bytes().to_vec();
  msg_to_hash.extend(DOMAIN_SEPARATOR.to_vec());
  msg_to_hash.extend_from_slice(&msg);
  msg_to_hash.extend(counter.to_le_bytes());

  sha256_hasher(msg_to_hash)
}

fn hash_to_curve(x: Vec<u8>) -> PublicKey {
  let mut counter: u32 = 0;
  let mut msg_hash = _get_hashed_value(x.clone(), counter);

  loop {
    if let Ok(x_only_pubkey) = XOnlyPublicKey::from_slice(&msg_hash) {
      return PublicKey::from_x_only_public_key(x_only_pubkey, Parity::Even);
    };
    counter += 1;
    msg_hash = _get_hashed_value(x.clone(), counter);
  }
}

fn get_point_on_curve(data: Vec<u8>) -> PublicKey {
  let mut message = data;
  loop {
    // If the public key is valid, return it
    if let Ok(x_only_pubkey) = XOnlyPublicKey::from_slice(&message) {
      return PublicKey::from_x_only_public_key(x_only_pubkey, Parity::Even);
    };
    // Otherwise, hash the message again and repeat
    message = sha256_hasher(message);
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn it_works() {
    Wallet::begin();
    assert!(true);
  }
}
