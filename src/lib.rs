use std::result;
use std::{collections::HashMap, error::Error};

use bitcoin::{
  key::Secp256k1,
  secp256k1::{Parity, PublicKey, Scalar, SecretKey, XOnlyPublicKey},
};
use rand::prelude::*;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

type Result<T> = result::Result<T, Box<dyn Error>>;
type Amount = u64;

/// A [`Proof`] is also called an `input` and is generated by Alice (wallet) from a [`BlindSignature`] it received.
/// An array [`Proof``] is called Proofs
#[derive(Debug, Serialize, Deserialize)]
struct Proof {
  /// amount of the [`Proof`]
  amount: Amount,
  /// keyset id of the mint public keys that signed the token (hex string)
  id: String,
  /// utf-8 encoded string (it is the `x`)
  secret: String,
  /// unblinded signature on `secret`
  #[serde(rename = "C")]
  c: PublicKey,
}

/// An encrypted ("blinded") secret and an amount is sent from Alice (wallet) to Bob (mint) for minting tokens or for swapping tokens.
/// A [`BlindedMessage`] is also called an `output`.
#[derive(Debug, Serialize, Deserialize)]
struct BlindedMessage {
  /// the value for the requested [`BlindSignature`]
  amount: Amount,
  /// requested keyset ID (hex) from which we expect a signature
  id: String,
  /// blinded secret message generated by Alice (wallet)
  #[serde(rename = "B_")]
  b: PublicKey,
}

/// A [`BlindSignature`] is sent from Bob (mint) to Alice (wallet) after minting tokens or after swapping tokens.
/// A [`BlindSignature`] is also called a `promise`.
#[derive(Debug, Serialize, Deserialize)]
struct BlindSignature {
  /// value of the blinded token
  amount: Amount,
  /// keyset id (hex) of the mint keys that signed the token
  id: String,
  /// blinded signature on the secret message `B_` sent by [`BlindedMessage`]
  #[serde(rename = "C_")]
  c: PublicKey,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Mint {
  secretkey: SecretKey,
  #[serde(rename = "K")]
  pub pubkey: PublicKey,
}

impl Mint {
  // Publishes its public key `K`.
  fn new() -> Self {
    let keypair = generate_key_pair();

    Self {
      secretkey: keypair.0,
      pubkey: keypair.1,
    }
  }

  // Signs message
  fn mint_or_swap_tokens(&self, message: BlindedMessage) -> Result<BlindSignature> {
    let BlindedMessage { b, id, amount } = message;

    let secp = Secp256k1::new();
    let scalar = Scalar::from(self.secretkey);
    // calculate C_ = kB_
    let c_ = b.mul_tweak(&secp, &scalar).expect("EC could not mul_tweak");

    // Bob sends back to Alice blinded key: C_ = kB_ (these two steps are the DH key exchange) (signing)
    Ok(BlindSignature { amount, id, c: c_ })
  }

  // checks that k*hash_to_curve(x) == C
  fn verification(&self, x: Vec<u8>, c: PublicKey) -> bool {
    let y = hash_to_curve(x);
    let secp = Secp256k1::new();
    let scalar = Scalar::from(self.secretkey);
    // calculate kY
    let ky = y.mul_tweak(&secp, &scalar).expect("EC could not mul_tweak");
    c == ky
  }
}

#[derive(Debug, Serialize, Deserialize)]
struct Wallet {}

impl Wallet {
  fn new() -> Self {
    Self {}
  }

  // Protocol
  fn begin(&self) {
    // Mint Bob publishes public key K = kG
    let mint = Mint::new();

    // Picks secret x
    let x = b"random-wallet-secret-message"; // x

    // Get r, the blinding factor. r \in [0, (p-1)/2) <- part of the curve
    let (blinding_factor, _) = generate_key_pair();

    // Computes `B_ = Y + rG`, with r being a random blinding factor (blinding)
    let blinded_message = self.blind(x.to_vec(), blinding_factor);

    // Alice sends to Bob:
    let blind_signature: BlindSignature;
    match mint.mint_or_swap_tokens(blinded_message) {
      Ok(value) => blind_signature = value,
      Err(e) => return eprintln!("Could not mint token: {e}"),
    }

    // Unblinds signature
    let c = self.unblind(&mint, blind_signature, blinding_factor);

    // Alice can take the pair (x, C) as a token and can send it to Carol.
    let token = (x, c);

    // verification
    let is_verified = mint.verification(token.0.to_vec(), token.1);
    println!("{}", is_verified);
  }

  fn blind(&self, x: Vec<u8>, blinding_factor: SecretKey) -> BlindedMessage {
    // Computes Y = hash_to_curve(x)
    let y = hash_to_curve(x.to_vec());

    let secp = Secp256k1::new();
    let blinding_factor_scalar = Scalar::from(blinding_factor);
    // calculate B_ = Y * rG      `rG` also know as `g^r` (`g^b` in lucre's document https://github.com/benlaurie/lucre/blob/master/html/theory2.pdf)
    let b_ = y
      .add_exp_tweak(&secp, &blinding_factor_scalar) // y + rG
      .expect("EC could not add_exp_tweak");

    let blinded_message = BlindedMessage {
      amount: 10,
      b: b_,
      id: "first#test".to_string(),
    };

    blinded_message
  }

  fn unblind(
    &self,
    mint: &Mint,
    blind_signature: BlindSignature,
    blinding_factor: SecretKey,
  ) -> PublicKey {
    // Alice can calculate the unblinded key as C_ - rK = kY + krG - krG = kY = C (unblinding)
    let secp = Secp256k1::new();
    // calculate scalar of blinding_factor
    let blinding_factor_scalar = Scalar::from(blinding_factor);
    // calculate rK
    let rk = mint
      .pubkey
      .mul_tweak(&secp, &blinding_factor_scalar)
      .expect("EC could not add_exp_tweak");
    // calculate C = C_ - rK
    let c = blind_signature
      .c
      .combine(&rk.negate(&secp))
      .expect("EC combine math error");

    c
  }
}

fn generate_private_key() -> SecretKey {
  let mut random: StdRng = SeedableRng::from_entropy();
  let secp = Secp256k1::new();
  let (secret_key, _) = secp.generate_keypair(&mut random);
  secret_key
}

const DOMAIN_SEPARATOR: &[u8] = "Secp256k1_HashToCurve_Cashu_".as_bytes();

fn sha256_hasher(data: Vec<u8>) -> Vec<u8> {
  let mut hasher = Sha256::new();
  hasher.update(data);
  hasher.finalize()[..].to_vec()
}

fn _get_hashed_value(msg: Vec<u8>, counter: u32) -> Vec<u8> {
  let mut msg_to_hash = 0x02_u8.to_be_bytes().to_vec();
  msg_to_hash.extend(DOMAIN_SEPARATOR.to_vec());
  msg_to_hash.extend_from_slice(&msg);
  msg_to_hash.extend(counter.to_le_bytes());

  sha256_hasher(msg_to_hash)
}

fn hash_to_curve(x: Vec<u8>) -> PublicKey {
  let mut counter: u32 = 0;
  let mut msg_hash = _get_hashed_value(x.clone(), counter);

  loop {
    if let Ok(x_only_pubkey) = XOnlyPublicKey::from_slice(&msg_hash) {
      return PublicKey::from_x_only_public_key(x_only_pubkey, Parity::Even);
    };
    counter += 1;
    msg_hash = _get_hashed_value(x.clone(), counter);
  }
}

fn get_point_on_curve(data: Vec<u8>) -> PublicKey {
  let mut message = data;
  loop {
    // If the public key is valid, return it
    if let Ok(x_only_pubkey) = XOnlyPublicKey::from_slice(&message) {
      return PublicKey::from_x_only_public_key(x_only_pubkey, Parity::Even);
    };
    // Otherwise, hash the message again and repeat
    message = sha256_hasher(message);
  }
}

fn generate_key_pair() -> (SecretKey, PublicKey) {
  let mut random: StdRng = SeedableRng::from_entropy();
  let secp = Secp256k1::new();
  let pair = secp.generate_keypair(&mut random);
  pair
}

fn get_public_key_from_private_key(private_key: Vec<u8>) -> PublicKey {
  let secp = Secp256k1::new();
  let secret_key = SecretKey::from_slice(&private_key).expect("32 bytes, within curve order");
  let public_key = PublicKey::from_secret_key(&secp, &secret_key);
  public_key
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn it_works() {
    let wallet = Wallet::new();
    wallet.begin();
    assert!(true);
  }
}
