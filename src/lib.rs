use std::error::Error;
use std::result;

use bitcoin::{
  key::Secp256k1,
  secp256k1::{Parity, PublicKey, Scalar, SecretKey, XOnlyPublicKey},
};
use rand::prelude::*;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

type Result<T> = result::Result<T, Box<dyn Error>>;
type Amount = u64;

const DOMAIN_SEPARATOR: &[u8] = "Secp256k1_HashToCurve_Cashu_".as_bytes();

/// An encrypted ("blinded") secret and an amount is sent from Alice (wallet) to Bob (mint) for minting tokens or for swapping tokens.
/// A [`BlindedMessage`] is also called an `output`.
#[derive(Debug, Serialize, Deserialize)]
struct BlindedMessage {
  /// the value for the requested [`BlindSignature`]
  amount: Amount,
  /// requested keyset ID (hex) from which we expect a signature
  id: String,
  /// blinded secret message generated by Alice (wallet)
  #[serde(rename = "B_")]
  b: PublicKey,
}

type BlindedMessages = Vec<BlindedMessage>;

/// A [`BlindSignature`] is sent from Bob (mint) to Alice (wallet) after minting tokens or after swapping tokens.
/// A [`BlindSignature`] is also called a `promise`.
#[derive(Debug, Serialize, Deserialize)]
struct BlindSignature {
  /// value of the blinded token
  amount: Amount,
  /// keyset id (hex) of the mint keys that signed the token
  id: String,
  /// blinded signature on the secret message `B_` sent by [`BlindedMessage`]
  #[serde(rename = "C_")]
  c: PublicKey,
}

/// A [`Proof`] is also called an `input` and is generated by Alice (wallet) from a [`BlindSignature`] it received.
/// An array [`Proof``] is called Proofs
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
struct Proof {
  /// amount of the [`Proof`]
  amount: Amount,
  /// keyset id of the mint public keys that signed the token (hex string)
  id: String,
  /// utf-8 encoded string (it is the `x`)
  secret: String,
  /// unblinded signature on `secret`
  #[serde(rename = "C")]
  c: PublicKey,
}

type Proofs = Vec<Proof>;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
struct Token {
  /// the mint URL
  mint: String,
  /// proofs of the token
  proofs: Proofs,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
struct CashuToken {
  token: Vec<Token>,
  /// optional currency unit of the token
  unit: Option<String>,
  /// optional text memo from the sender
  memo: Option<String>,
}
impl CashuToken {
  const PREFIX: &'static str = "cashu";
  const URI_PREFIX: &'static str = "cashu:";
  const VERSION: &'static str = "A";

  fn encode(&self, uri: Option<bool>) -> String {
    use base64::{engine::general_purpose::URL_SAFE, Engine as _};

    let json = serde_json::to_string(&self).unwrap_or_else(|_| String::new());
    let b64 = URL_SAFE.encode(json);

    if let Some(is_uri) = uri {
      if is_uri {
        return format!("{}{}{}{b64}", Self::URI_PREFIX, Self::PREFIX, Self::VERSION);
      }
    }

    format!("{}{}{b64}", Self::PREFIX, Self::VERSION)
  }

  pub fn decode(encoded: &str) -> Option<Self> {
    use base64::{engine::general_purpose::URL_SAFE, Engine as _};

    if encoded.starts_with(Self::URI_PREFIX) {
      let pat = format!("{}{}{}", Self::URI_PREFIX, Self::PREFIX, Self::VERSION);
      let b64 = encoded.trim_start_matches(&pat);
      let json = URL_SAFE.decode(&b64).ok()?;
      serde_json::from_slice(&json).ok()
    } else if encoded.starts_with(Self::PREFIX) {
      let pat = format!("{}{}", Self::PREFIX, Self::VERSION);
      let b64 = encoded.trim_start_matches(&pat);
      let json = URL_SAFE.decode(&b64).ok()?;
      serde_json::from_slice(&json).ok()
    } else {
      None
    }
  }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Mint {
  secretkey: SecretKey,
  #[serde(rename = "K")]
  pub pubkey: PublicKey,
}

impl Mint {
  // Publishes its public key `K`.
  fn new() -> Self {
    let keypair = generate_key_pair();

    Self {
      secretkey: keypair.0,
      pubkey: keypair.1,
    }
  }

  // Signs blinded message (an output)
  fn mint_or_swap_tokens(&self, message: BlindedMessage) -> Result<BlindSignature> {
    let BlindedMessage { b, id, amount } = message;

    let secp = Secp256k1::new();
    let scalar = Scalar::from(self.secretkey);
    // calculate C_ = kB_
    let c_ = b.mul_tweak(&secp, &scalar).expect("EC math could not mul_tweak");

    // Bob sends back to Alice blinded key (promise): C_ = kB_ (these two steps are the DH -blind- key exchange) (signing)
    Ok(BlindSignature { amount, id, c: c_ })
  }

  // checks that k*hash_to_curve(x) == C
  fn verification(&self, x: Vec<u8>, c: PublicKey) -> bool {
    let y = hash_to_curve(x);
    let secp = Secp256k1::new();
    let scalar = Scalar::from(self.secretkey);
    // calculate kY
    let ky = y.mul_tweak(&secp, &scalar).expect("EC math could not mul_tweak");
    c == ky
  }
}

#[derive(Debug, Serialize, Deserialize)]
struct Wallet {}

impl Wallet {
  fn new() -> Self {
    Self {}
  }

  fn begin(&self) {
    // Mint Bob publishes public key K = kG
    let mint = Mint::new();

    // Picks secret x (utf-8 encoded 32 bytes encoded string) -- coin ID
    let (x, _) = generate_key_pair();
    let x = x.secret_bytes();

    // Get r, the blinding factor. r \in [0, (p-1)/2) <- part of the curve
    let (blinding_factor, _) = generate_key_pair();

    // Computes `B_ = Y + rG`, with r being a random blinding factor (blinding)
    let blinded_message = self.blind(x.to_vec(), blinding_factor);

    // Alice sends blinded message to Bob
    let blind_signature: BlindSignature;
    match mint.mint_or_swap_tokens(blinded_message) {
      Ok(value) => blind_signature = value,
      Err(e) => return eprintln!("Could not mint token: {e}"),
    }

    // Unblinds signature
    let c = self.unblind(&mint, blind_signature, blinding_factor);

    // Alice can take the pair (x, C) as a token and can send it to Carol.
    let token = (x, c);

    // verification
    let is_verified = mint.verification(token.0.to_vec(), token.1);
    println!("{}", is_verified);
  }

  fn blind(&self, x: Vec<u8>, blinding_factor: SecretKey) -> BlindedMessage {
    // Computes Y = hash_to_curve(x)
    let y = hash_to_curve(x.to_vec());

    let secp = Secp256k1::new();
    let blinding_factor_scalar = Scalar::from(blinding_factor);
    // calculate `B_ = Y * rG`. `rG` also know as `g^r` (`g^b` in lucre's document https://github.com/benlaurie/lucre/blob/master/html/theory2.pdf)
    let b_ = y
      .add_exp_tweak(&secp, &blinding_factor_scalar) // y + rG
      .expect("EC math could not add_exp_tweak");

    let blinded_message = BlindedMessage {
      amount: 10,
      b: b_,
      id: hex::encode(x),
    };

    blinded_message
  }

  fn unblind(
    &self,
    mint: &Mint,
    blind_signature: BlindSignature,
    blinding_factor: SecretKey,
  ) -> PublicKey {
    // Alice can calculate the unblinded key as C_ - rK = kY + krG - krG = kY = C (unblinding)
    let secp = Secp256k1::new();
    // calculate scalar of blinding_factor
    let blinding_factor_scalar = Scalar::from(blinding_factor);
    // calculate rK
    let rk = mint
      .pubkey
      .mul_tweak(&secp, &blinding_factor_scalar)
      .expect("EC math could not mul_tweak");
    // calculate C = C_ - rK
    let c = blind_signature
      .c
      .combine(&rk.negate(&secp))
      .expect("EC math combine math error");

    c
  }
}

fn sha256_hasher(data: Vec<u8>) -> Vec<u8> {
  let mut hasher = Sha256::new();
  hasher.update(data);
  hasher.finalize()[..].to_vec()
}

fn _get_hashed_value(msg: Vec<u8>, counter: u32) -> Vec<u8> {
  let mut msg_to_hash = 0x02_u8.to_be_bytes().to_vec();
  msg_to_hash.extend(DOMAIN_SEPARATOR.to_vec());
  msg_to_hash.extend_from_slice(&msg);
  msg_to_hash.extend(counter.to_le_bytes());

  sha256_hasher(msg_to_hash)
}

fn hash_to_curve(x: Vec<u8>) -> PublicKey {
  let mut counter: u32 = 0;
  let mut msg_hash = _get_hashed_value(x.clone(), counter);

  loop {
    if let Ok(x_only_pubkey) = XOnlyPublicKey::from_slice(&msg_hash) {
      return PublicKey::from_x_only_public_key(x_only_pubkey, Parity::Even);
    };
    counter += 1;
    msg_hash = _get_hashed_value(x.clone(), counter);
  }
}

fn generate_key_pair() -> (SecretKey, PublicKey) {
  let mut random: StdRng = SeedableRng::from_entropy();
  let secp = Secp256k1::new();
  let pair = secp.generate_keypair(&mut random);
  pair
}

#[cfg(test)]
mod tests {
  use serde_json::json;

  use super::*;

  #[test]
  fn it_works() {
    let wallet = Wallet::new();
    wallet.begin();
    assert!(true);
  }

  #[test]
  fn token_encoding_decoding() {
    let example_json_token = json!(
      {
        "token": [
          {
            "mint": "https://8333.space:3338",
            "proofs": [
              {
                "amount": 2,
                "id": "009a1f293253e41e",
                "secret": "407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837",
                "C": "02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea"
              },
              {
                "amount": 8,
                "id": "009a1f293253e41e",
                "secret": "fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be",
                "C": "029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059"
              }
            ]
          }
        ],
        "unit": "sat",
        "memo": "Thank you."
      }
    );
    let expected_serialized = "cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9";
    let expected_serialized_uri = "cashu:cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9";

    let decoded_token_from_json: CashuToken =
      serde_json::from_value(example_json_token).expect("decode json");

    let decoded_token_from_serialized =
      CashuToken::decode(expected_serialized).expect("decode cashutoken");
    assert_eq!(decoded_token_from_json, decoded_token_from_serialized);
    let decoded_token_from_serialized_uri =
      CashuToken::decode(expected_serialized_uri).expect("decode uri cashutoken");
    assert_eq!(decoded_token_from_json, decoded_token_from_serialized_uri);

    let serialized = decoded_token_from_serialized.encode(None);
    assert_eq!(expected_serialized, serialized);
    let serialized_uri = decoded_token_from_serialized.encode(Some(true));
    assert_eq!(expected_serialized_uri, serialized_uri);

    assert_eq!(
      CashuToken::decode(&decoded_token_from_json.encode(None)).expect("decode token round trip"),
      decoded_token_from_json
    );
    assert_eq!(
      CashuToken::decode(&decoded_token_from_json.encode(Some(true)))
        .expect("decode uri token round trip"),
      decoded_token_from_json
    );
  }
}
